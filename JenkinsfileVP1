pipeline {
  agent any

  environment {
    KCFG_ID     = 'k8s-jenkins'                 // kubeconfig 凭据ID
    POD_TMPL    = 'macos-pod.yaml'              // Pod 模板
    BUILD_NODE  = "macos-${env.BUILD_TAG}"      // 本次构建唯一节点名
    JENKINS_URL = 'http://17.87.2.137:8080'     // Jenkins 根URL（不要以 / 结尾）
  }

  options { timestamps() }

  stages {

    stage('Create Jenkins Node') {
      steps {
        withCredentials([usernameColonPassword(credentialsId: 'jenkins-api', variable: 'JAUTH')]) {
          script {
            def NODE = env.BUILD_NODE
            def JURL = (env.JENKINS_URL?.trim()) ?: 'http://17.87.2.137:8080'

            // 1) 写入节点 XML（注意 \$ 的转义）
            writeFile file: 'node.xml', text: """
<slave>
  <name>${NODE}</name>
  <description>ephemeral macOS</description>
  <remoteFS>/Users/test/jenkins-agent</remoteFS>
  <numExecutors>1</numExecutors>
  <mode>NORMAL</mode>
  <retentionStrategy class="hudson.slaves.RetentionStrategy\\\$Always"/>
  <launcher class="hudson.slaves.JNLPLauncher">
    <webSocket>true</webSocket>
  </launcher>
  <label>${NODE}</label>
  <nodeProperties/>
</slave>
""".stripIndent()

            // 2) 取 crumb -> /scriptText 创建/更新 -> 覆盖 config.xml -> 解析 JNLP secret（不跑 kubectl）
            sh """#!/bin/bash
set -xeuo pipefail
NODE='${NODE}'
JURL='${JURL}'

	# 取 CSRF crumb
	if command -v jq >/dev/null 2>&1; then
	  CRUMB=\$(curl -fsS -u "\$JAUTH" "\$JURL/crumbIssuer/api/json" | jq -r .crumb)
	else
	  CRUMB=\$(curl -fsS -u "\$JAUTH" "\$JURL/crumbIssuer/api/json" | sed -n 's/.*"crumb"[[:space:]]*:[[:space:]]*"\\([^"]*\\)".*/\\1/p')
	fi
	[ -n "\$CRUMB" ] || { echo "Failed to get CRUMB"; exit 1; }

	# 写到临时文件，避免 read -d '' 的坑
	cat > .scriptText.groovy <<GROOVY
	import jenkins.model.Jenkins
	import hudson.model.Node
	import hudson.slaves.DumbSlave
	import hudson.slaves.RetentionStrategy
	import hudson.slaves.JNLPLauncher
	import java.util.LinkedList

	def name   = "${NODE}"            // ← 直接嵌入 bash 里的 NODE 值
	def labels = name
	def home   = "/Users/test/jenkins-agent"
	
	def j = Jenkins.get()
	def n = j.getNode(name)
	def launcher = new JNLPLauncher()
	launcher.setWebSocket(true)

	if (n == null) {
	  n = new DumbSlave(name, "ephemeral macOS", home, "1",
		Node.Mode.NORMAL, labels, launcher,
		new RetentionStrategy.Always(), new LinkedList())
	  j.addNode(n)
	} else {
	  n.setLauncher(launcher)
	  n.setLabelString(labels)
	  n.setNumExecutors(1)
	  n.setMode(Node.Mode.NORMAL)
	  j.save()
	}
	println "READY"
	GROOVY

		export NODE_NAME="\$NODE"
	
	# 执行 /scriptText
	RESP=\$(curl -fsS -u "\$JAUTH" -H "Jenkins-Crumb: \$CRUMB" \\
	  --data-urlencode script@.scriptText.groovy \\
	  "\$JURL/scriptText")
	echo "\$RESP" | grep -q READY || { echo "scriptText create node failed"; echo "\$RESP" | head -200; exit 1; }
	
	# 覆盖节点 config.xml（幂等）
	curl -fsS -u "\$JAUTH" -H "Jenkins-Crumb: \$CRUMB" \\
		 -X POST -H 'Content-Type: application/xml' \\
		 --data-binary @node.xml \\
		 "\$JURL/computer/\$NODE/config.xml"

		# 解析 JNLP secret（新旧路径兼容）
		sleep 2
		HTTP1=\$(curl -u "\$JAUTH" -w '%{http_code}' -fsSLo .jnlp1 "\$JURL/computer/\$NODE/jenkins-agent.jnlp" || true)
		HTTP2=\$(curl -u "\$JAUTH" -w '%{http_code}' -fsSLo .jnlp2 "\$JURL/computer/\$NODE/slave-agent.jnlp"   || true)
		echo "jenkins-agent.jnlp http=\$HTTP1, slave-agent.jnlp http=\$HTTP2"
		
		SECRET=""
		SECRET=\$(grep -hoE -- '--secret [0-9a-f]{64,}' .jnlp1 .jnlp2 2>/dev/null | head -1 | awk '{print \$2}') || true
		if [ -z "\$SECRET" ]; then
		  SECRET=\$(grep -hoE -- '<argument>[0-9a-f]{64,}</argument>' .jnlp1 .jnlp2 2>/dev/null | head -1 | sed -E 's#</?argument>##g') || true
		fi
		[ -n "\$SECRET" ] || { echo "no JNLP secret parsed"; head -50 .jnlp1 .jnlp2 2>/dev/null || true; exit 1; }
		echo "\$SECRET" > .jnlp.secret
		echo "Parsed JNLP secret length=\${#SECRET}"
		"""

		// 关键：从文件读回到 Groovy 变量
		def SECRET = readFile('.jnlp.secret').trim()
		echo "Groovy got SECRET length=${SECRET.length()}"
		
		
		// 3) 现在进入 withKubeConfig，下发 K8s Secret 时，使用 Groovy 变量插值
		withKubeConfig([credentialsId: env.KCFG_ID]) {
		  sh """#!/bin/bash
		set -xeuo pipefail
		kubectl -n ci delete secret jenkins-macos-${NODE} --ignore-not-found || true
		kubectl -n ci create secret generic jenkins-macos-${NODE} \\
		  --from-literal=JENKINS_URL=${JURL} \
		  --from-literal=JENKINS_NODE_NAME=${NODE} \
		  --from-literal=JENKINS_SECRET=${SECRET}  \
		  --from-literal=VM_USER=test \
		  --from-literal=VM_PASS=test 
		"""
            }
          }
        }
      }
    }

    stage('Launch VM Pod') {
      steps {
        sh 'cp /var/jenkins_home/pod-templates/macos-pod.yaml .'
        withKubeConfig([credentialsId: env.KCFG_ID]) {
          sh """
            sed -e "s/__BUILD_ID__/${BUILD_NODE}/g" \
                -e "s/__HOST_PORT__/30222/g"  \
                -e "s/__VZ_USER__/test/g" \
                -e "s/__VZ_PASS__/test/g" macos-pod.yaml > rendered.yaml

            echo '===== rendered.yaml (compute env) ====='
            awk '/name: compute/{f=1} f{print} /name: jenkins-bootstrap/{f=0}' rendered.yaml
            echo '======================================'

            kubectl -n ci apply -f rendered.yaml
          """
          
          sh '''
            kubectl -n ci wait --for=condition=Initialized --timeout=120s pod/macos-build-${BUILD_NODE} || true

            kubectl -n ci describe pod macos-build-${BUILD_NODE} | sed -n '/Events:/,$p'
            kubectl -n ci get pod macos-build-${BUILD_NODE} -o wide || true

            kubectl -n ci get pod macos-build-${BUILD_NODE} -o json \
              | jq '.spec.containers[] | select(.name=="jenkins-bootstrap") | {envFrom: .envFrom, env: .env}' || true

            kubectl -n ci get secret jenkins-macos-${BUILD_NODE} -o jsonpath='{.data.JENKINS_URL}' | base64 -d; echo
            kubectl -n ci get secret jenkins-macos-${BUILD_NODE} -o jsonpath='{.data.JENKINS_SECRET}' | base64 -d | awk '{print "LEN=" length}'

        
          '''
          sh '''
            POD=macos-build-${BUILD_NODE}

            # 每个容器的等待原因/信息
            kubectl -n ci get pod "$POD" -o jsonpath='{range .status.containerStatuses[*]}{.name}{" => "}{.state.waiting.reason}{" : "}{.state.waiting.message}{"\n"}{end}' || true
            echo

            # 只看 jenkins-bootstrap 的详细等待对象
            kubectl -n ci get pod "$POD" -o json \
              | jq '.status.containerStatuses[] | select(.name=="jenkins-bootstrap")' || true

            # 相关事件（按时间排序）
            kubectl -n ci get events --field-selector involvedObject.name="$POD" --sort-by=.lastTimestamp || true
          '''
          sh '''
            kubectl -n ci get pod macos-build-${BUILD_NODE} -o yaml \
              | sed -n "/containerStatuses:/,/^$/p" || true
          '''
          sh """
            kubectl -n ci get pod macos-build-${BUILD_NODE} -o wide || true
          """
        }
      }
    }
  
	stage('Cred debug: ssh private key (137ssh)') {
	  steps {
		withCredentials([sshUserPrivateKey(credentialsId: '137ssh',
										   keyFileVariable: 'SSH_KEY',
										   usernameVariable: 'SSH_USER')]) {
		  sh '''#!/bin/bash
			set -euo pipefail
			echo "[DEBUG] local host: $(hostname)"
			
			ssh -i "$SSH_KEY" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
			   "$SSH_USER@17.87.2.137" 'echo "[REMOTE] ok from $(hostname)"'
			'''
			}
	  }
	}


	 stage('Build on macOS') {
	  agent { label "${env.BUILD_NODE}" }
	
	  steps {
	    withCredentials([string(credentialsId: 'macos-login-keychain-pass', variable: 'KEYCHAIN_PASS')]) {
		  sh '''#!/bin/bash
		  set -euo pipefail
		  set +u
		  LOGIN_KC="${HOME}/Library/Keychains/login.keychain-db"
		  KEYCHAIN_PASS="${KEYCHAIN_PASS:-}"
		  set -u
		
		  : "${KEYCHAIN_PASS:?KEYCHAIN_PASS is empty — configure Jenkins credential 'macos-login-keychain-pass'}"
		
		  [ -f "$LOGIN_KC" ] || security create-keychain -p "${KEYCHAIN_PASS}" "$LOGIN_KC"
		  security unlock-keychain -p "${KEYCHAIN_PASS}" "$LOGIN_KC"
		  security default-keychain -s "$LOGIN_KC"
		  security list-keychains -d user -s "$LOGIN_KC"
		  security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "${KEYCHAIN_PASS}" "$LOGIN_KC"
		  '''
		}
	  
		// 1) 连通性
		sh '''#!/bin/bash
		set -euo pipefail
		hostname
		sw_vers
		'''
	
		// 2) 拉取 provisioning profile（用 Jenkins 中 ID=137ssh 的私钥）
		
		sh '''#!/bin/bash
		set -euo pipefail
		# 在当前工作区自动找 .xcworkspace 或 .xcodeproj
		if compgen -G "*.xcworkspace" >/dev/null; then
		  Project_Name=$(ls *.xcworkspace | head -1 | sed 's/\\.xcworkspace$//')
		elif compgen -G "*.xcodeproj" >/dev/null; then
		  Project_Name=$(ls *.xcodeproj | head -1 | sed 's/\\.xcodeproj$//')
		else
		  echo "[ERR] 未找到 .xcworkspace 或 .xcodeproj"
		  exit 1
		fi
		
		echo "[INFO] Project_Name=$Project_Name"

			
			
		# 检测 workspace 或 project
		if [ -d "${Project_Name}.xcworkspace" ]; then
		  echo "[INFO] Detected workspace: ${Project_Name}.xcworkspace"
		  project_scheme=$(xcodebuild -list -workspace "${Project_Name}.xcworkspace" \
			| awk '/Schemes:/{flag=1;next}/^$/{flag=0}flag' \
			| head -1 | xargs)
		else
		  echo "[INFO] Detected project: ${Project_Name}.xcodeproj"
		  project_scheme=$(xcodebuild -list -project "${Project_Name}.xcodeproj" \
			| awk '/Schemes:/{flag=1;next}/^$/{flag=0}flag' \
			| head -1 | xargs)
		fi
		echo "[INFO] project_scheme=$project_scheme"
		
		# 自动获取第一个 Build Configuration
		if [ -d "${Project_Name}.xcworkspace" ]; then
		  Configuration=$(xcodebuild -list -workspace "${Project_Name}.xcworkspace" \
			| awk '/Build Configurations:/{flag=1;next}/If no build configuration/{flag=0}flag' \
			| head -1 | xargs)
		else
		  Configuration=$(xcodebuild -list -project "${Project_Name}.xcodeproj" \
			| awk '/Build Configurations:/{flag=1;next}/If no build configuration/{flag=0}flag' \
			| head -1 | xargs)
		fi
		echo "[INFO] Configuration=$Configuration"
			
			
			# ========== 可配置项（也可在 Jenkins 环境变量里覆盖） ==========
			SEARCH_ROOT="${WORKSPACE:-$PWD}"           # 在哪个目录查找（默认工作区）
			PROFILE_GLOB="${PROFILE_GLOB:-*.mobileprovision *.provisionprofile}"  # 查找模式
			PREFER_BUNDLEID="${PREFER_BUNDLEID:-}"     # 若想优先选择某个 BundleID 的 profile，可设置它；留空则按修改时间最新
			# ============================================================
			
			cat > _pick_profile.sh <<'BASH'
			set -euo pipefail
			
			SEARCH_ROOT="${SEARCH_ROOT:-$PWD}"
			PROFILE_GLOB=${PROFILE_GLOB:-"*.mobileprovision *.provisionprofile"}
			PREFER_BUNDLEID="${PREFER_BUNDLEID:-}"
			
			# 收集候选（按时间倒序），兼容 bash 3.2
			CANDIDATES=()
			# shellcheck disable=SC2086
			while IFS= read -r f; do
			  [ -n "$f" ] && CANDIDATES+=("$f")
			done < <(cd "$SEARCH_ROOT" && ls -1t ${PROFILE_GLOB} 2>/dev/null || true)
			
			if [ ${#CANDIDATES[@]} -eq 0 ]; then
			  echo "[ERR] 没找到 *.mobileprovision / *.provisionprofile；请把 profile 放到仓库里或设置 PROFILE_GLOB"
			  exit 1
			fi
			
			# 读取 APPID（TEAMID.bundleid），兼容纯 XML 情况
			read_appid() {
			  local pf="$1" tmp err
			  tmp="$(mktemp /tmp/_pp.XXXXXX.plist)"
			  err="$(mktemp /tmp/_pp.err.XXXXXX)"
			  if /usr/bin/security cms -D -i "$pf" >"$tmp" 2>"$err"; then
				: # ok
			  else
				if file "$pf" | grep -qi 'XML'; then
				  cp "$pf" "$tmp"
				else
				  rm -f "$tmp" "$err"
				  return 1
				fi
			  fi
			  APPID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' "$tmp" 2>/dev/null || echo "")
			  rm -f "$tmp" "$err"
			  [ -n "$APPID" ]
			}
			
			pick_profile() {
			  local f pf
			
			  # 有 PREFER_BUNDLEID 时，先精确匹配（用 shell 通配判断，避免正则转义问题）
			  if [ -n "$PREFER_BUNDLEID" ]; then
				for f in "${CANDIDATES[@]}"; do
				  pf="$SEARCH_ROOT/$f"
				  if read_appid "$pf"; then
					# APPID 形如 TEAMID.com.xxx.yyy
					local bid="${APPID#*.}"
					if [ "$bid" = "$PREFER_BUNDLEID" ]; then
					  printf '%s\n' "$pf"
					  return 0
					fi
				  fi
				done
			  fi
			
			  # 否则按时间最新
			  printf '%s\n' "$SEARCH_ROOT/${CANDIDATES[0]}"
			  return 0
			}
			
			PROFILE="$(pick_profile)"
			echo "[PICK] $PROFILE"
			# 回传路径给外层
			printf '%s' "$PROFILE" > _picked_profile.path
			BASH
			
			# 执行子脚本
			SEARCH_ROOT="$SEARCH_ROOT" PROFILE_GLOB="$PROFILE_GLOB" PREFER_BUNDLEID="$PREFER_BUNDLEID" bash _pick_profile.sh
			
			PROFILE="$(cat _picked_profile.path)"
			echo "[PICK] $PROFILE"
			
			
			#  解包为 plist
			PLIST="$(mktemp /tmp/_pp.XXXXXX.plist)"
			SECERR="$(mktemp /tmp/_pp.err.XXXXXX)"
			if /usr/bin/security cms -D -i "$PROFILE" > "$PLIST" 2>"$SECERR"; then
			  echo "[OK] security cms -> $PLIST"
			else
			  echo "[WARN] security cms failed:"
			  cat "$SECERR" || true
			  if file "$PROFILE" | grep -qi 'XML'; then
				cp "$PROFILE" "$PLIST"
			  else
				exit 1
			  fi
			fi
			/usr/bin/plutil -lint "$PLIST"
			
			#  读取关键字段
			NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' "$PLIST")
			UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' "$PLIST")
			APPID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' "$PLIST" 2>/dev/null || echo "")
			TEAM_FROM_ENT=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:com.apple.developer.team-identifier' "$PLIST" 2>/dev/null || echo "")
			GET_TASK_ALLOW=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:get-task-allow' "$PLIST" 2>/dev/null || echo "false")
			PLATFORM0=$(/usr/libexec/PlistBuddy -c 'Print :Platform:0' "$PLIST" 2>/dev/null || echo "")
			
			TEAMID="${TEAM_FROM_ENT:-${APPID%%.*}}"
			BUNDLEID="${APPID#*.}"
			
			echo "[PP] Name=$NAME"
			echo "[PP] UUID=$UUID"
			echo "[PP] TeamID=$TEAMID"
			echo "[PP] BundleID=$BUNDLEID"
			echo "[PP] get-task-allow=$GET_TASK_ALLOW"
			echo "[PP] Platform[0]=$PLATFORM0"
			
			#  判定开发/发布 & 目标平台
			if [[ "$GET_TASK_ALLOW" == "true" ]]; then
			  PROFILE_KIND="development"
			  CERT_KIND="Apple Development"
			else
			  PROFILE_KIND="distribution"
			  CERT_KIND="Apple Distribution"
			fi
			
			if echo "$PLATFORM0" | grep -Eqi 'xros|visionOS'; then
			  DESTINATION="generic/platform=visionOS"
			else
			  DESTINATION="generic/platform=iOS"
			fi
			echo "[PP] kind=$PROFILE_KIND  dest=$DESTINATION  cert=$CERT_KIND"
			
			#  安装 profile
			DEST_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
			mkdir -p "$DEST_DIR"
			/usr/bin/install -m 0644 "$PROFILE" "$DEST_DIR/${UUID}.mobileprovision"
			echo "[INSTALL] $DEST_DIR/${UUID}.mobileprovision"
			
			#  自动挑选匹配证书（钥匙串需已导入带私钥的证书）
			CODE_SIGN_IDENTITY=$(security find-identity -v -p codesigning \
			  | awk -v kind="$CERT_KIND" -v team="$TEAMID" -F\" '$0 ~ kind && $0 ~ "\\(" team "\\)" {print $2; exit}')
			
			if [[ -z "${CODE_SIGN_IDENTITY:-}" ]]; then
			  echo "[ERR] 找不到匹配证书（$CERT_KIND, Team=$TEAMID）。请确认证书+私钥已导入 login 钥匙串并解锁。"
			  security find-identity -v -p codesigning || true
			  exit 1
			fi
			echo "[CERT] $CODE_SIGN_IDENTITY"
			
			#  导出变量供 xcodebuild 使用（名称+UUID都导出，随你选）
			export CPROVISIONING_PROFILE_NAME="$NAME"
			export PROVISIONING_PROFILE_UUID="$UUID"
			export DEVELOPMENT_TEAM="$TEAMID"
			export PRODUCT_BUNDLE_IDENTIFIER="$BUNDLEID"
			export CODE_SIGN_IDENTITY="$CODE_SIGN_IDENTITY"
			export DESTINATION="$DESTINATION"
			
			echo "[ENV] CPROVISIONING_PROFILE_NAME=$CPROVISIONING_PROFILE_NAME"
			echo "[ENV] PRODUCT_BUNDLE_IDENTIFIER=$PRODUCT_BUNDLE_IDENTIFIER"
			echo "[ENV] DEVELOPMENT_TEAM=$DEVELOPMENT_TEAM"
			echo "[ENV] CODE_SIGN_IDENTITY=$CODE_SIGN_IDENTITY"
			echo "[ENV] DESTINATION=$DESTINATION"
				
				

		
		project_workspace="${Project_Name}.xcworkspace"	
		project_proj="${Project_Name}.xcodeproj"	
		build_dir="${WORKSPACE}/build"
		archive_path="${build_dir}/${project_scheme}.xcarchive"
		export_path="${HOME}/project/build/${Project_Name}"
		exportOptionsPlist="${build_dir}/${project_scheme}.plist"	
		
		mkdir -p "${build_dir}" "${export_path}"
				
		# 记录变量
		cat > BuildVariable <<EOF
		project_workspace=${project_workspace}
		project_scheme=${project_scheme}
		export_path=${export_path}
		build_dir=${build_dir}
		archive_path=${archive_path}
		exportOptionsPlist=${exportOptionsPlist}
EOF
		
		if [ -f "$project_workspace" ]; then
		  echo "[BUILD] Use workspace: $project_workspace"
		  xcodebuild -list -workspace "$project_workspace" || true
		  SRC_OPTS=(-workspace "$project_workspace")
		else
		  echo "[BUILD] Use project: $project_proj"
		  xcodebuild -list -project "$project_proj" || true
		  SRC_OPTS=(-project "$project_proj")
		fi
		
		echo "check3"
		
		# 生成 exportOptionsPlist（手工签名，用 Name 绑定 profile）
		cat > "${exportOptionsPlist}" <<PL
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
		<plist version="1.0"><dict>
		  <key>signingStyle</key><string>manual</string>
		  <key>method</key><string>development</string>
		  <key>signingCertificate</key><string>Apple Development</string>
		  <key>provisioningProfiles</key><dict>
			<key>${BundleID}</key><string>${CPROVISIONING_PROFILE_NAME}</string>
		  </dict>
		  <key>stripSwiftSymbols</key><true/>
		  <key>compileBitcode</key><true/>
		</dict></plist>
PL
		
		
		
		
		
		echo " 构建 Archive "
		xcodebuild \
		  "${SRC_OPTS[@]}" \
		  -scheme "$project_scheme" \
		  -configuration "$Configuration" \
		  clean archive \
		  -archivePath "$archive_path" \
		  -destination 'generic/platform=iOS' \
		  DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
		  CODE_SIGN_IDENTITY="$CODE_SIGN_IDENTITY" \
		  PRODUCT_BUNDLE_IDENTIFIER="$BundleID" \
		  PROVISIONING_PROFILE_SPECIFIER="$CPROVISIONING_PROFILE_NAME" \
		  -allowProvisioningUpdates \
		  -allowProvisioningDeviceRegistration \
		  -UseModernBuildSystem=NO \
		  -quiet
		  
		echo " 导出 IPA"		
		xcodebuild -exportArchive \
		  -archivePath "$archive_path" \
		  -exportOptionsPlist "$exportOptionsPlist" \
		  -exportPath "$export_path" \
		  -quiet
		
		echo "[BUILD] exported:"
		ls -lh "$export_path" || true
		'''
		  }
		
		 //  5) 在这个 stage 的 post 里收集产物（仍在 macOS 节点上）"	
		  post {
			always {
			  script {
			  withCredentials([sshUserPrivateKey(credentialsId: '137ssh',
                                   keyFileVariable: 'SSH_KEY',
                                   usernameVariable: 'SSH_USER')]) {
		sh '''#!/bin/bash
		set -euo pipefail
		
		REMOTE="17.87.2.137"
		REMOTE_BASE="/Users/mdsadmin/Documents"
		RUN_DIR="${JOB_BASE_NAME}#${BUILD_NUMBER}"
		REMOTE_DIR="${REMOTE_BASE}/${RUN_DIR}"
		
		echo "读取构建阶段写下的变量；做兜底，避免 set -u 触发"		
		[ -f BuildVariable ] && source BuildVariable || true
		export_path=${export_path:-}
		archive_path=${archive_path:-}
		project_scheme=${project_scheme:-app}
		
		echo "[REMOTE] mkdir -p ${REMOTE_DIR}"
		ssh -i "$SSH_KEY" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
			"$SSH_USER@$REMOTE" "mkdir -p \"${REMOTE_DIR}\""
		
		echo "传 ipa"
		if [ -n "$export_path" ] && ls "$export_path"/*.ipa >/dev/null 2>&1; then
		  echo "[UPLOAD] ipa -> ${REMOTE}:${REMOTE_DIR}"
		  scp -i "$SSH_KEY" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
			  "$export_path"/*.ipa \
			  "$SSH_USER@$REMOTE:${REMOTE_DIR}/"
		else
		  echo "[UPLOAD] no ipa found under ${export_path}"
		fi
		
		echo " .xcarchive（用 rsync 更快且可断点续传） "
		if [ -n "$archive_path" ] && [ -d "$archive_path" ]; then
		  echo "[UPLOAD] xcarchive -> ${REMOTE}:${REMOTE_DIR}/${project_scheme}.xcarchive/"
		  rsync -a \
			-e "ssh -i $SSH_KEY -o IdentitiesOnly=yes -o StrictHostKeyChecking=no" \
			"$archive_path"/ \
			"$SSH_USER@$REMOTE:${REMOTE_DIR}/${project_scheme}.xcarchive/"
		else
		  echo "[UPLOAD] no xcarchive dir at ${archive_path}"
		fi
		
		echo "附带上传变量文件，便于远端排查"
		[ -f BuildVariable ] && scp -i "$SSH_KEY" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
			BuildVariable "$SSH_USER@$REMOTE:${REMOTE_DIR}/" || true
		
		echo "[DONE] artifacts uploaded to ${REMOTE}:${REMOTE_DIR}"
		'''
		}
			  }
			}
		  }
		}
      }
  
  
  
  post {
    always {   
    	 withKubeConfig([credentialsId: env.KCFG_ID]) {
    	   sh "kubectl -n ci delete pod macos-build-${BUILD_NODE} --ignore-not-found"
       	   sh "kubectl -n ci delete secret jenkins-macos-${BUILD_NODE} --ignore-not-found"
      }
    }
  }
}